diff a/lido-fiv/contracts/LidoVault.sol b/lido-fiv/contracts/LidoVault.sol	(rejected hunks)
@@ -47,7 +47,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
   uint256 public appliedProtocolFee;
 
   /// @notice ETH amount that tracks the total Saffron protocol fee from variable withdrawal staking earnings while the vault is still ongoing
-  uint256 public totalProtocolFee;
+  uint256 public ongoingProtocolFeeInShares;
 
   /// @notice Address that collects the Saffron protocol fee
   address public protocolFeeReceiver;
@@ -55,7 +55,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
   /// @notice Penalty fee in basis points for fixed side early withdrawals that is quadratically scaled based off of the amount of time that has elapsed since the vault started
   uint256 public earlyExitFeeBps;
 
-   /// @notice Total stETH capacity of the fixed side on vault start
+  /// @notice Total stETH capacity of the fixed side on vault start
   uint256 public fixedSidestETHOnStartCapacity;
 
   /// @notice Minimum amount of ETH that can be deposited for variable or fixed side users
@@ -123,6 +123,9 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
   /// @notice Amount of ETH used to cover the returning of fixed user's initial principal
   uint256 public vaultEndedFixedDepositsFunds;
 
+  /// @notice Amount of earnings in ETH from Lido Staking after the vault has ended that was already withdrawn
+  uint256 public vaultEndedWithdrawnStakingEarnings;
+
   /// @notice Mapping from user addresses to the upfront premium a fixed depositor received from the variable side
   mapping(address => uint256) public userToFixedUpfrontPremium;
 
@@ -176,7 +179,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
   mapping(address => uint256) public variableToWithdrawnStakingEarningsInShares;
 
   /// @notice Mapping from variable side user addresses to their total payed protocol fee amount right after their Lido withdrawal request is submitted
-  mapping(address => uint256) public variableToWithdrawnProtocolFee;
+  mapping(address => uint256) public variableToWithdrawnProtocolFeeInShares;
 
   /// @notice Mapping from variable side user addresses to their total withdrawn fees amount right after their Lido withdrawal request is claimed
   mapping(address => uint256) public variableToWithdrawnFees;
@@ -287,7 +290,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
     require(params.protocolFeeReceiver != address(0), "NEI");
 
     require(params.fixedSideCapacity.mulDiv(minimumFixedDepositBps, 10_000) >= minimumDepositAmount, "IFC");
-
+    require(params.variableSideCapacity >= minimumDepositAmount, "IVC");
     // Initialize contract state variables
     id = params.vaultId;
     duration = params.duration;
@@ -379,8 +382,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
 
     // Start the vault if we're at capacity
     if (
-      fixedETHDepositTokenTotalSupply == fixedSideCapacity &&
-      variableBearerTokenTotalSupply == variableSideCapacity
+      fixedETHDepositTokenTotalSupply == fixedSideCapacity && variableBearerTokenTotalSupply == variableSideCapacity
     ) {
       startTime = block.timestamp;
       endTime = block.timestamp + duration;
@@ -441,10 +443,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
 
         // Request withdrawal of their stETH shares
         // Add the requestIds associated with the user who submitted the withdrawal
-        fixedToVaultNotStartedWithdrawalRequestIds[msg.sender] = requestWithdrawViaShares(
-          msg.sender,
-          claimBalance
-        );
+        fixedToVaultNotStartedWithdrawalRequestIds[msg.sender] = requestWithdrawViaShares(msg.sender, claimBalance);
 
         emit LidoWithdrawalRequested(
           msg.sender,
@@ -520,29 +519,29 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
           uint256 lidoStETHBalance = stakingBalance();
           uint256 fixedETHDeposits = fixedSidestETHOnStartCapacity;
 
-        // staking earnings have accumulated on Lido
-        if (lidoStETHBalance > fixedETHDeposits + minStETHWithdrawalAmount()) {
-          uint256 currentStakes = stakingShares();
-          (uint256 currentState, uint256 ethAmountOwed) = calculateVariableWithdrawState(
-            (lidoStETHBalance.mulDiv(currentStakes + withdrawnStakingEarningsInStakes, currentStakes) - fixedETHDeposits),
-            variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(lidoStETHBalance, currentStakes)
-          );
-          if (ethAmountOwed >= minStETHWithdrawalAmount()) {
-            // estimate protocol fee and update total - will actually be applied on withdraw finalization
-            uint256 protocolFee = ethAmountOwed.mulDiv(protocolFeeBps, 10000);
-            totalProtocolFee += protocolFee;
-            uint256 stakesAmountOwed = lido.getSharesByPooledEth(ethAmountOwed);
-
-            withdrawnStakingEarnings += ethAmountOwed - protocolFee;
-            withdrawnStakingEarningsInStakes += stakesAmountOwed;
-
-            variableToWithdrawnStakingEarnings[msg.sender] += ethAmountOwed - protocolFee;
-            variableToWithdrawnStakingEarningsInShares[msg.sender] += stakesAmountOwed;
-            variableToWithdrawnProtocolFee[msg.sender] += protocolFee;
-            variableToVaultOngoingWithdrawalRequestIds[msg.sender] = requestWithdrawViaETH(
-              msg.sender,
-              ethAmountOwed
+          // staking earnings have accumulated on Lido
+          if (lidoStETHBalance > fixedETHDeposits + MIN_STETH_WITHDRAWAL_AMOUNT) {
+            uint256 currentStakes = stakingShares();
+            (uint256 currentState, uint256 ethAmountOwed) = calculateVariableWithdrawState(
+              (lidoStETHBalance.mulDiv(currentStakes + withdrawnStakingEarningsInStakes, currentStakes) -
+                fixedETHDeposits),
+              variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(lidoStETHBalance, currentStakes)
             );
+            ethAmountOwed = Math.min(ethAmountOwed, lidoStETHBalance - fixedETHDeposits);
+            if (ethAmountOwed >= MIN_STETH_WITHDRAWAL_AMOUNT) {
+              // estimate protocol fee and update total - will actually be applied on withdraw finalization
+              uint256 protocolFee = ethAmountOwed.mulDiv(protocolFeeBps, 10000);
+              uint256 protocolFeeInShares = lido.getSharesByPooledEth(protocolFee);
+              ongoingProtocolFeeInShares += protocolFeeInShares;
+              uint256 stakesAmountOwed = lido.getSharesByPooledEth(ethAmountOwed);
+
+              withdrawnStakingEarnings += ethAmountOwed - protocolFee;
+              withdrawnStakingEarningsInStakes += stakesAmountOwed;
+
+              variableToWithdrawnStakingEarnings[msg.sender] += ethAmountOwed - protocolFee;
+              variableToWithdrawnStakingEarningsInShares[msg.sender] += stakesAmountOwed;
+              variableToWithdrawnProtocolFeeInShares[msg.sender] += protocolFeeInShares;
+              variableToVaultOngoingWithdrawalRequestIds[msg.sender] = requestWithdrawViaETH(msg.sender, ethAmountOwed);
 
               emit LidoWithdrawalRequested(
                 msg.sender,
@@ -609,9 +621,9 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
   /// @notice Finalize a variable withdrawal that was requested after the vault has started
   function finalizeVaultOngoingVariableWithdrawals() external {
     uint256[] memory requestIds = variableToVaultOngoingWithdrawalRequestIds[msg.sender];
-    if(variableToPendingWithdrawalAmount[msg.sender] != 0) {
+    if (variableToPendingWithdrawalAmount[msg.sender] != 0) {
       withdrawAmountVariablePending();
-      if(requestIds.length == 0) {
+      if (requestIds.length == 0) {
         return;
       }
     }
@@ -653,7 +665,8 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
   function withdrawAmountVariablePending() public {
     uint256 amount = variableToPendingWithdrawalAmount[msg.sender];
     variableToPendingWithdrawalAmount[msg.sender] = 0;
-    payable(msg.sender).transfer(amount);
+    (bool sent, ) = payable(msg.sender).call{value: amount}("");
+    require(sent, "ETF");
   }
 
   /// @notice Finalize the vault ended withdrawals
@@ -675,6 +688,8 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
     if (amountWithdrawn > fixedETHDeposit) {
       vaultEndedStakingEarnings = amountWithdrawn - fixedETHDeposit;
       vaultEndedFixedDepositsFunds = fixedETHDeposit;
+      vaultEndingStakesAmount -= (fixedETHDeposit * vaultEndingStakesAmount) / vaultEndingETHBalance;
+      vaultEndingETHBalance = vaultEndedStakingEarnings;
     } else {
       vaultEndedFixedDepositsFunds = amountWithdrawn;
     }
@@ -709,17 +724,17 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
   function vaultEndedWithdraw(uint256 side) internal {
     if (vaultEndedWithdrawalRequestIds.length == 0 && !vaultEndedWithdrawalsFinalized) {
       emit VaultEnded(block.timestamp, msg.sender);
-      if (stakingBalance() < minStETHWithdrawalAmount()) {
-
+      uint256 stakingBalance = stakingBalance();
+      if (stakingBalance < MIN_STETH_WITHDRAWAL_AMOUNT) {
         claimOngoingFixedWithdrawals();
         vaultEndingStakesAmount = stakingShares();
-        vaultEndingETHBalance = stakingBalance();
+        vaultEndingETHBalance = stakingBalance;
         // not enough staking ETH to withdraw just override vault ended state and continue the withdraw
         vaultEndedWithdrawalsFinalized = true;
       } else {
         vaultEndingStakesAmount = stakingShares();
-        vaultEndingETHBalance = stakingBalance();
-        vaultEndedWithdrawalRequestIds = requestEntireBalanceWithdraw(msg.sender);
+        vaultEndingETHBalance = stakingBalance;
+        vaultEndedWithdrawalRequestIds = requestWithdrawViaETH(msg.sender, stakingBalance);
 
         emit LidoWithdrawalRequested(msg.sender, vaultEndedWithdrawalRequestIds, side, true, true);
         // need to call finalizeVaultEndedWithdrawals once request is processed
@@ -745,10 +760,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
         uint256 bearerBalance = fixedBearerToken[msg.sender];
         //uint256 bearerBalance = fixedBearerToken.balanceOf(msg.sender);
         require(bearerBalance > 0, "NBT");
-        sendAmount = fixedBearerToken[msg.sender].mulDiv(
-          vaultEndedFixedDepositsFunds,
-          fixedLidoSharesTotalSupply()
-        );
+        sendAmount = fixedBearerToken[msg.sender].mulDiv(vaultEndedFixedDepositsFunds, fixedLidoSharesTotalSupply());
 
         fixedBearerToken[msg.sender] = 0;
         fixedBearerTokenTotalSupply -= bearerBalance;
@@ -771,17 +783,28 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
 
       // Return proportional share of both earnings to caller
       uint256 stakingShareAmount = 0;
-
-      uint256 totalEarnings = vaultEndingETHBalance.mulDiv(withdrawnStakingEarningsInStakes,vaultEndingStakesAmount) - totalProtocolFee  + vaultEndedStakingEarnings;
-
-      if (totalEarnings > 0) {
-        (uint256 currentState, uint256 stakingEarningsShare) = calculateVariableWithdrawState(
-          totalEarnings,
-          variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(vaultEndingETHBalance, vaultEndingStakesAmount)
-        );
-        stakingShareAmount = stakingEarningsShare;
-        variableToWithdrawnStakingEarningsInShares[msg.sender] = currentState.mulDiv(vaultEndingStakesAmount,vaultEndingETHBalance);
-        variableToWithdrawnStakingEarnings[msg.sender] = currentState;
+      if (vaultEndingETHBalance >= MIN_STETH_WITHDRAWAL_AMOUNT) {
+        uint256 totalEarnings = vaultEndingETHBalance.mulDiv(
+          withdrawnStakingEarningsInStakes - ongoingProtocolFeeInShares,
+          vaultEndingStakesAmount
+        ) + vaultEndedStakingEarnings;
+        if (totalEarnings > 0) {
+          (uint256 currentState, uint256 stakingEarningsShare) = calculateVariableWithdrawState(
+            totalEarnings,
+            (variableToWithdrawnStakingEarningsInShares[msg.sender] -
+              variableToWithdrawnProtocolFeeInShares[msg.sender]).mulDiv(vaultEndingETHBalance, vaultEndingStakesAmount)
+          );
+          stakingShareAmount = Math.min(
+            stakingEarningsShare,
+            vaultEndedStakingEarnings - vaultEndedWithdrawnStakingEarnings
+          );
+          vaultEndedWithdrawnStakingEarnings += stakingShareAmount;
+          variableToWithdrawnStakingEarningsInShares[msg.sender] += stakingShareAmount.mulDiv(
+            vaultEndingStakesAmount,
+            vaultEndingETHBalance
+          );
+          variableToWithdrawnStakingEarnings[msg.sender] += stakingShareAmount;
+        }
       }
 
       uint256 feeShareAmount = 0;
@@ -803,7 +826,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
   /// @notice Returns all fixed side Lido shares - claimed or unclaimed
   /// @return totalSupply Total supply of the fixed bearer and claim tokens
   function fixedLidoSharesTotalSupply() internal view returns (uint256) {
-	return fixedBearerTokenTotalSupply + fixedClaimTokenTotalSupply;
+    return fixedBearerTokenTotalSupply + fixedClaimTokenTotalSupply;
   }
 
   /// @notice Helper function to claim a Lido fixed withdrawal that was requested after the vault has started
@@ -860,7 +883,6 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
     uint256 totalEarnings,
     uint256 previousWithdrawnAmount
   ) internal view returns (uint256, uint256) {
-
     uint256 bearerBalance = variableBearerToken[msg.sender];
     require(bearerBalance > 0, "NBT");
 
@@ -872,17 +894,23 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
 
     return (ethAmountOwed + previousWithdrawnAmount, ethAmountOwed);
   }
-  
+
   /// @notice Helper function to calculate the ongoing variable withdraw state
   /// The vault must track a variable user's withdrawals during the duration of the vault since withdrawals can be executed at any time
   /// @param user for whom the withdrawal variable amount is calculated
   /// @return (ethAmountOwed) The amount to withdraw
   function getCalculateVariableWithdrawStateWithStakingBalance(address user) public view returns (uint256) {
     uint256 lidoStETHBalance = stakingBalance();
-    uint256 fixedETHDeposits = fixedETHDepositTokenTotalSupply;
+    uint256 currentStakes = stakingShares();
+    uint256 fixedETHDeposits = fixedSidestETHOnStartCapacity;
     require(lidoStETHBalance > fixedETHDeposits, "LBL");
-    uint256 totalEarnings = (lidoStETHBalance - fixedETHDeposits) + withdrawnStakingEarnings + totalProtocolFee;
-    uint256 previousWithdrawnAmount = variableToWithdrawnStakingEarnings[user].mulDiv(10000, 10000 - protocolFeeBps);
+
+    uint256 totalEarnings = lidoStETHBalance.mulDiv(currentStakes + withdrawnStakingEarningsInStakes, currentStakes) -
+      fixedETHDeposits;
+    uint256 previousWithdrawnAmount = variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(
+      lidoStETHBalance,
+      currentStakes
+    );
 
     uint256 bearerBalance = variableBearerToken[user];
     require(bearerBalance > 0, "NBT");
@@ -906,7 +934,6 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
     uint256 previousWithdrawnAmount,
     address user
   ) internal view returns (uint256, uint256) {
-
     uint256 bearerBalance = variableBearerToken[user];
     require(bearerBalance > 0, "NBT");
 
@@ -989,7 +1016,7 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
     );
 
     // Calculate the scaling fee based on the linear factor and earlyExitFeeBps
-    uint256 earlyExitFees = upfrontPremium.mulDiv( (1 + earlyExitFeeBps).mulDiv(remainingProportion, 1e18), 10000);
+    uint256 earlyExitFees = upfrontPremium.mulDiv((1 + earlyExitFeeBps).mulDiv(remainingProportion, 1e18), 10000);
 
     // Calculate the amount to be paid back of their original upfront claimed premium, not influenced by quadratic scaling
     earlyExitFees += upfrontPremium - upfrontPremium.mulDiv(timestampRequested - startTime, duration);
@@ -1114,15 +1141,6 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
     return requestWithdrawViaETH(user, stETHAmount);
   }
 
-  /// @notice Request a withdrawal of the entire stETH balance of the contract
-  /// @param user Address of the user that is requesting the withdraw
-  /// @return requestIds Ids of the withdrawal requests
-  function requestEntireBalanceWithdraw(address user) internal returns (uint256[] memory) {
-    uint256 stETHAmount = stakingBalance();
-
-    return requestWithdrawViaETH(user, stETHAmount);
-  }
-
   /// @notice Request a withdrawal on Lido to exchange stETH for ETH via stETH amount
   /// @param user Address of the user that is requesting the withdraw
   /// @param stETHAmount Amount of stETH to withdraw
@@ -1227,5 +1245,4 @@ contract LidoVault is ILidoVaultInitializer, ILidoVault {
 
     return withdrawalAmounts;
   }
-
 }
